#!/usr/bin/env ruby
begin
require 'optparse'
require "timeseries"

options = {
  :n_steps => 1,
  :offset => 0,
  :period => "1s",
  :zone   => "UTC",
  :format => 0,
  :signature => [],
  :snap_start_time => :next,
  :snap_stop_time => :previous,
  :unbuffer => false,
  :mode => :stream
}

OptionParser.new do |opts|
  opts.banner = %{
usage: timeseries [options] [PRINT_FORMATS...|FILES...]

  Generate time series data.

options:
}.lstrip

  opts.on("-a", "--adjust TYPE", "adjust start/stop (inner)") do |code|
    case code
    when "pp"          then options.merge!(:snap_start_time => :previous, :snap_stop_time => :previous)
    when "pn", "outer" then options.merge!(:snap_start_time => :previous, :snap_stop_time => :next)
    when "np", "inner" then options.merge!(:snap_start_time => :next, :snap_stop_time => :previous)
    when "nn"          then options.merge!(:snap_start_time => :next, :snap_stop_time => :next)
    when "none"        then options.merge!(:snap_start_time => nil, :snap_stop_time => nil)
    else raise "invalid rounding type: #{code}"
    end
  end

  opts.on("-d", "--debug", "debug mode") do
    $DEBUG = true
  end

  opts.on("-f", "--format FORMAT", "strftime format") do |str|
    options[:format] = str
  end

  opts.on("-h", "--help", "print this help") do
    puts opts
    puts
    exit
  end

  opts.on("-i", "--iso8601 [PRECISION]", "iso8601 format (0)") do |value|
    options[:format] = value.to_i
  end

  opts.on("-k", "--tick", "tick according to FILES") do
    options[:mode] = :tick
  end

  opts.on("-K", "--series-tick", "tick, limited by series") do
    options[:mode] = :series_tick
  end

  opts.on("-n", "--n-steps N", "number of steps (#{options[:n_steps]})") do |n_steps|
    options[:n_steps] = n_steps.to_i
    options[:signature] << :n_steps
  end

  opts.on("-o", "--offset OFFSET", "offset (#{options[:offset]})") do |offset|
    options[:offset] = offset.to_i
  end

  opts.on("-p", "--period PERIOD", "period (#{options[:period]})") do |period|
    options[:period] = period
    options[:signature] << :period
  end

  opts.on("-r", "--realtime", "print in realtime (assumes -u)") do |code|
    options[:mode] = :realtime
    options[:unbuffer] = true
  end

  opts.on("-R", "--series-realtime", "realtime, limited by series") do |code|
    options[:mode] = :series_realtime
    options[:unbuffer] = true
  end

  opts.on("-s", "--start START_TIME", "start time (now)") do |start_time|
    options[:start_time] = start_time
    options[:signature] << :start_time
  end

  opts.on("-t", "--stop STOP_TIME", "stop time") do |stop_time|
    options[:stop_time] = stop_time
    options[:signature] << :stop_time
  end

  opts.on("-u", "--[no-]unbuffer", "unbuffer output (#{options[:zone]})") do |value|
    options[:unbuffer] = value
  end

  opts.on("-z", "--zone ZONE", "timezone (#{options[:zone]})") do |zone|
    options[:zone] = zone
  end
end.parse!

Time.zone = options[:zone]
options[:start_time] ||= Time.zone.now

format = options[:format]
if format.kind_of?(Integer)
  formatter = lambda {|time| time.iso8601(format) }
else
  formatter = lambda {|time| time.strftime(format) }
end

if options[:unbuffer]
  $stdout.sync = true
end

timeseries = Timeseries.create(options)

case mode = options[:mode]
when :stream
  printformats = ARGV.dup; ARGV.clear
  if printformats.empty?
    printformats << "%{time}"
  end

  timeseries.each_with_index do |step, index|
    options[:index] = index
    options[:time]  = formatter.call(step)
    printformats.each do |printformats|
      puts printformats % options
    end
  end
when :tick
  index = timeseries.offset
  while printformat = ARGF.gets
    step = timeseries.at(index)
    options[:index] = index
    options[:time]  = formatter.call(step)
    print printformat % options
    index += 1
  end
when :series_tick
  timeseries.each_with_index do |step, index|
    if printformat = ARGF.gets
      options[:index] = index
      options[:time]  = formatter.call(step)
      print printformat % options
    else
      break
    end
  end
when :realtime
  printformats = ARGV.dup; ARGV.clear
  if printformats.empty?
    printformats << "%{time}"
  end

  index = timeseries.offset
  step  = timeseries.at(index)
  loop do
    options[:index] = index
    options[:time]  = formatter.call(step)

    index += 1
    next_step = timeseries.at(index)

    printformats.each do |printformats|
      puts printformats % options
    end

    sleep(next_step - step)
    step = next_step
  end
when :series_realtime
  printformats = ARGV.dup; ARGV.clear
  if printformats.empty?
    printformats << "%{time}"
  end

  step = nil
  timeseries.each_with_index do |next_step, next_index|
    if step
      options[:index] = next_index - 1
      options[:time]  = formatter.call(step)
      printformats.each do |printformats|
        puts printformats % options
      end
      sleep(next_step - step)
    end

    step = next_step
  end

  options[:index] = timeseries.n_steps - 1
  options[:time]  = formatter.call(step)
  printformats.each do |printformats|
    puts printformats % options
  end
end

rescue Interrupt
  exit 130
rescue Errno::EPIPE 
  exit 0
rescue
  raise if $DEBUG
  $stderr.puts $!.message
  exit 1
end